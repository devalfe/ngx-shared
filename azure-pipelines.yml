# Azure DevOps Pipeline — Validate + Release (semantic-release to npm.pkg.github.com) + DocsDeploy

trigger:
  branches:
    include: [main, develop]

pr:
  branches:
    include: [main, develop]

variables:
  - group: v-group-global
  - name: NODE_VERSION
    value: '22.x'
  - name: LIB_DIR
    value: 'projects/ngx-global-state'
  - name: DIST_DIR
    value: 'dist/ngx-global-state'
  - name: DOCS_DIR
    value: 'docs'

stages:
  # ──────────────────────────────────────────────────────────────────────────────
  # 1) CI — instala, lint, test, build y publica dist como artefacto
  # ──────────────────────────────────────────────────────────────────────────────
  - stage: CI
    displayName: 'CI: install + lint + test + build + artifact'
    jobs:
      - job: build_and_test
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 0

          - task: NodeTool@0
            displayName: 'Use Node $(NODE_VERSION)'
            inputs:
              versionSpec: '$(NODE_VERSION)'

          - script: |
              corepack enable || true
              node -v
              npm -v
            displayName: 'Node info'

          - task: Cache@2
            inputs:
              key: 'npm | "$(Agent.OS)" | package-lock.json'
              path: '$(Pipeline.Workspace)/.npm'
              restoreKeys: |
                npm | "$(Agent.OS)"
            displayName: 'Cache npm'

          - script: HUSKY=0 npm ci --cache "$(Pipeline.Workspace)/.npm" --prefer-offline
            displayName: 'npm ci'
            env:
              GITHUB_TOKEN: $(GITHUB_TOKEN)

          - script: |
              if npm run | grep -q "lint"; then npm run lint; else echo "No lint script"; fi
              if npm run | grep -q "format:check"; then npm run format:check; else echo "No format:check script"; fi
            displayName: 'ESLint / Prettier (check)'

          - script: |
              if npm run | grep -q "test:ci"; then npm run test:ci; else echo "No tests"; fi
            displayName: 'Unit tests'

          - script: |
              if npm run | grep -q "docs"; then npm run docs; else echo "No docs"; fi
            displayName: 'Generate docs (Compodoc)'

          - publish: $(DOCS_DIR)
            artifact: docs
            condition: succeededOrFailed()
            displayName: 'Publish docs artifact'

          - script: npm run build:lib
            displayName: 'Build library'

          - publish: $(DIST_DIR)
            artifact: ngx-global-state-dist
            displayName: 'Publish dist artifact'

  # ──────────────────────────────────────────────────────────────────────────────
  # 2) SECURITY — auditoría de dependencias y lint estricto
  # ──────────────────────────────────────────────────────────────────────────────
  - stage: SECURITY
    displayName: 'Security: npm audit + strict lint'
    dependsOn: CI
    condition: succeeded()
    jobs:
      - job: security_checks
        pool: { vmImage: 'ubuntu-latest' }
        steps:
          - checkout: self
            fetchDepth: 0
          - task: NodeTool@0
            inputs: { versionSpec: '$(NODE_VERSION)' }

          - script: HUSKY=0 npm ci
            displayName: 'npm ci'
            env:
              GITHUB_TOKEN: $(GITHUB_TOKEN)

          - script: npm audit --audit-level=high
            displayName: 'npm audit (fail on high)'

          - script: |
              if npm run | grep -q "lint"; then npm run lint; else echo "No lint script"; fi
            displayName: 'ESLint strict'

        # (Opcional) CodeQL / MS Security DevOps si usas la extensión
        # - task: MicrosoftSecurityDevOps@1
        #   inputs: { productSelection: 'codeql,dependency' }

  # ──────────────────────────────────────────────────────────────────────────────
  # 3) QA — tras aprobación del environment `qa`, publicar canary (next)
  #     versión: X.Y.Z-next.<BuildId> (no modifica el repo; solo dist)
  # ──────────────────────────────────────────────────────────────────────────────
  - stage: QA
    displayName: 'QA: Publish canary (dist-tag: next) to GPR'
    dependsOn: [CI, SECURITY]
    condition: succeeded()
    jobs:
      - deployment: canary_publish
        environment: qa # <-- configura approval en Environments
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  fetchDepth: 0
                - task: NodeTool@0
                  inputs: { versionSpec: '$(NODE_VERSION)' }

                - task: DownloadPipelineArtifact@2
                  inputs:
                    buildType: current
                    artifactName: ngx-global-state-dist
                    targetPath: '$(Pipeline.Workspace)/ngx-dist'
                  displayName: 'Download dist artifact'

                - script: |
                    set -euo pipefail
                    IFS=$'\n\t'

                    PKG="@devalfe/ngx-global-state"         # <-- cambia si aplica
                    REG="https://npm.pkg.github.com"
                    DIST="$(Pipeline.Workspace)/ngx-dist"   # <-- ajusta si tu ruta es otra

                    # Lee versión base (X.Y.Z) desde el package.json FUENTE (no el de dist)
                    BASE=$(node -e "console.log((require('./projects/ngx-global-state/package.json').version||'0.0.0').split('-')[0])")

                    # Vars de ADO en bash
                    BUILD="${BUILD_BUILDID:-0}"             # de Build.BuildId
                    ATTEMPT="${SYSTEM_JOBATTEMPT:-1}"       # de System.JobAttempt

                    # Candidato 1: X.Y.Z-next.BUILD
                    CANDY="${BASE}-next.${BUILD}"

                    exists() {
                      npm view "${PKG}@${1}" version --registry="${REG}" > /dev/null 2>&1
                    }

                    if exists "${CANDY}"; then
                      # Candidato 2: X.Y.Z-next.BUILD.ATTEMPT
                      CANDY="${BASE}-next.${BUILD}.${ATTEMPT}"
                      if exists "${CANDY}"; then
                        # Candidato 3: X.Y.Z-next.BUILD.ATTEMPT.<epoch>
                        TS=$(date +%s)
                        CANDY="${BASE}-next.${BUILD}.${ATTEMPT}.${TS}"
                      fi
                    fi

                    echo "Canary version → ${CANDY}"

                    # Autenticación para GPR
                    echo "@devalfe:registry=${REG}" > ~/.npmrc           # <-- cambia @devalfe si tu scope difiere
                    echo "//npm.pkg.github.com/:_authToken=$(GITHUB_TOKEN)" >> ~/.npmrc
                    echo "always-auth=true" >> ~/.npmrc

                    # Verifica login
                    npm whoami --registry="${REG}"

                    # Asegura publishConfig.registry y version en el package.json de DIST
                    node -e "const fs=require('fs');const p='${DIST}/package.json';const j=JSON.parse(fs.readFileSync(p,'utf8')); j.version='${CANDY}'; j.publishConfig={...(j.publishConfig||{}), registry:'${REG}'}; fs.writeFileSync(p, JSON.stringify(j,null,2)); console.log('Updated',p)"

                    # Publica con tag 'next'
                    cd "${DIST}"
                    npm publish --tag next --access=public --registry="${REG}"
                  displayName: 'Publish canary (unique version) to GitHub Packages'
                  env:
                    GITHUB_TOKEN: $(GITHUB_TOKEN)

  # ──────────────────────────────────────────────────────────────────────────────
  # 4) RELEASE — tras aprobación de `prod` (y solo en main), semantic-release
  #     calcula versión, publica a GPR, CHANGELOG y (si añades plugin) GitHub Release
  # ─────────────────────────────────────────────────────────────────────────@─────
  - stage: RELEASE
    displayName: 'Release: semantic-release → GPR + CHANGELOG (+ GitHub Release opcional)'
    dependsOn: [CI, SECURITY, QA]
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: release_release
        environment: prod
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  persistCredentials: true
                  fetchDepth: 0
                - task: NodeTool@0
                  inputs: { versionSpec: '$(NODE_VERSION)' }
                - task: Cache@2
                  inputs:
                    key: 'npm | "$(Agent.OS)" | package-lock.json'
                    path: '$(Pipeline.Workspace)/.npm'
                    restoreKeys: |
                      npm | "$(Agent.OS)"
                    displayName: 'Cache npm'
                - script: HUSKY=0 npm ci --cache "$(Pipeline.Workspace)/.npm" --prefer-offline
                  displayName: 'npm ci'
                  env:
                    GITHUB_TOKEN: $(GITHUB_TOKEN)

                - script: npm run build:lib
                  displayName: 'Build library (for semantic-release)'

                - script: |
                    export HUSKY=0
                    npx semantic-release --repositoryUrl "$(Build.Repository.Uri)"
                  displayName: 'Run semantic-release (publish to npm.pkg.github.com)'
                  env:
                    NPM_TOKEN: $(GITHUB_TOKEN)
                    GITHUB_TOKEN: $(System.AccessToken)

  # ──────────────────────────────────────────────────────────────────────────────
  # DOCS DEPLOY — Despliega Compodoc a Azure Static Web Apps desde artefacto
  # ──────────────────────────────────────────────────────────────────────────────
  - stage: DOCS_DEPLOY
    displayName: 'Deploy Docs to Azure Static Web Apps'
    dependsOn: CI
    condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
    jobs:
      - job: deploy_docs
        displayName: 'Deploy docs (from artifact)'
        pool: { vmImage: 'ubuntu-latest' }
        steps:
          - checkout: self
            fetchDepth: 1

          # 1) Descargar el artefacto "docs" a una ruta conocida dentro del repo
          - task: DownloadPipelineArtifact@2
            displayName: 'Download docs artifact'
            inputs:
              buildType: current
              artifactName: docs
              targetPath: '$(Build.SourcesDirectory)/_site'

          # 2) Verificación y normalización de estructura
          - script: |
              set -euxo pipefail
              echo "Listing $(Build.SourcesDirectory)/_site"
              ls -la '$(Build.SourcesDirectory)/_site' || true

              # Verifica index.html en raíz; si vino anidado, súbelo un nivel
              if [ ! -f '$(Build.SourcesDirectory)/_site/index.html' ]; then
                if [ -f '$(Build.SourcesDirectory)/_site/docs/index.html' ]; then
                  mv '$(Build.SourcesDirectory)/_site/docs/'* '$(Build.SourcesDirectory)/_site/'
                fi
              fi

              test -f '$(Build.SourcesDirectory)/_site/index.html'
            displayName: 'Verify docs layout'

          # 3) Deploy an Azure Static Web Apps (no re-build)
          - task: AzureStaticWebApp@0
            displayName: 'Deploy to Azure Static Web Apps'
            inputs:
              app_location: '_site' # relativa al directorio de trabajo
              output_location: '.' # no aplica para contenido estático
              skip_app_build: true
            env:
              azure_static_web_apps_api_token: $(SWA_DEPLOYMENT_TOKEN)
